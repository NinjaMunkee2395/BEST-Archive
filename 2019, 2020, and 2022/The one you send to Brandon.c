#pragma config(Motor,  port2,           LDrive,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           ArmL,          tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           RDrive,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           ArmR,          tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

	//Global variables used for autonomous activation signals
	bool autoA = false;
	bool autoB = false;

/*===================================================================================*/
//This task controls all of the movement for the wheels necessary to play the game.
task drive(){
	float left, right;	//Our left and right variables are used for holding the values that we will output to the left and right motors
	while(true){
		if(abs(vexRT[Ch3]) < 10 && abs(vexRT[Ch2]) < 10)	//To make-up for any human flinching
		{
			motor[LDrive] = 0;
			motor[RDrive] = 0;
		}
		else
		{
			//Tank Drive-style
			//Formulate a slope calculation for smoother movement using an exponential curve
			left = pow(vexRT[Ch3],3)/pow(127,2);
			right = pow(vexRT[Ch2],3)/pow(127,2);
			if(left > 127)	//Cap the output at 127 to ensure we don't overpower the motors
			{
				left=127;
			}
			else if(left < -127)
			{
				left = -127;
			}
			if(right > 127)
			{
				right = 127;
			}
			else if(right < -127)
			{
				right = -127;
			}
			motor[LDrive] = left;	//Send the calculated output to the motors
			motor[RDrive] = right;
		}
	}
}

/*===================================================================================*/

/*task ClawTask(){
	int open = -90;	//Open servo position
	int close = 127;	//Close servo position

	motor[TriClaw] = open;

	while (true)
	{
		if(vexRT[Btn8D] == true)
		{
			motor[TriClaw] = open;
		}
		else if(vexRT[Btn8L] == true)
		{
			motor[TriClaw] = close;
		}
	}
}

/*===================================================================================*/
//This task controls all of the movement for the arm necessary to play the game.
task ArmCtrl(){
	while(true)
	{
		if(vexRT[Btn6U] == true)	//Move the arm up at full speed
		{
			motor[ArmR] = 127;
			motor[ArmL] = 127;
		}
		else if(vexRT[Btn6D] == true)	//Move the arm down at full speed
		{
			motor[ArmR] = -127;
			motor[ArmL] = -127;
		}
		else if(vexRT[Btn5U] == true)	//Slowly move the arm up for finer control
		{
			motor[ArmR] = 90;
			motor[ArmL] = 90;
		}
		else if(vexRT[Btn5D] == true)	//Slowly move the arm down for finer control
		{
			motor[ArmR] = -90;
			motor[ArmL] = -90;
		}
	}
}

/*===================================================================================*/
//Autonomous mode for near tower
task AutoModeA(){
	//Move towards the tower, then stop when it reaches the near tower before reversing slightly
	motor[LDrive] = 127;
	motor[RDrive] = 127;
	wait1Msec(2400);
	motor[LDrive] = 0;
	motor[RDrive] = 0;
	wait1Msec(100);
	motor[LDrive] = -127;
	motor[RDrive] = -127;
	wait1Msec(600);
	motor[LDrive] = 0;
	motor[RDrive] = 0;
	startTask (drive);
}

/*===================================================================================*/
//Autonomous mode for far tower
task AutoModeB(){
	//Move towards the tower, then stop when it reaches the far tower before reversing slightly
	motor[LDrive] = 127;
	motor[RDrive] = 127;
	wait1Msec(3300);
	motor[LDrive] = 0;
	motor[RDrive] = 0;
	wait1Msec(100);
	motor[LDrive] = -127;
	motor[RDrive] = -127;
	wait1Msec(700);
	motor[LDrive] = 0;
	motor[RDrive] = 0;
	startTask (drive);
}

/*===================================================================================*/

task main(){
	//Start the tasks that control driving and arm movement
	startTask(drive);
	//startTask(ClawTask);
	startTask(ArmCtrl);

	//To reset autonomous flags
	autoA = false;
	autoB = false;

	//This while loop will continuously check for input from the driver for autonomous mode activation while the robot is still on.
	while(true){
		wait1Msec(10);
		if(vexRT[Btn7U] == true && autoA == false)
		{
			autoA = true;	//Raise the autoA flag
			stopTask(drive);	//To keep the drive task from interfeering with the robot
			startTask(AutoModeA);
		}
		//Interupting autonomous mode & restart remote control driving
		else if(autoA == true && (abs(vexRT[Ch2]) > 10 || abs(vexRT[Ch3]) > 10))
		{
			autoA = false;	//Clear the autoA flag
			stopTask(AutoModeA);
			startTask(drive);
		}
		if(vexRT[Btn7D] == true && autoB == false)
		{
			autoB = true;	//Raise the autoB flag
			stopTask(drive);	//To keep the drive task from interfeering with the robot
			startTask(AutoModeB);
		}
		//Interupting autonomous mode & restart remote control driving
		else if(autoB == true && (abs(vexRT[Ch2]) > 10 || abs(vexRT[Ch3]) > 10))
		{
			autoB = false;	//Clear the autoB flag
			stopTask(AutoModeB);
			startTask(drive);
		}
	}
}	// End of Code

#pragma config(Motor,  port2,           LDrive,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           Pi,            tmotorServoStandard, openLoop)
#pragma config(Motor,  port7,           RDrive,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           TriClaw,       tmotorServoStandard, openLoop)
#pragma config(Motor,  port9,           Arm,           tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*===================================================================================*/
task drive()
{
	float left, right;
	autoA = false;
	autoB = false;
	while(true){
		if(abs(vexRT[Ch3]) < 10 && abs(vexRT[Ch4]) < 10)	//To make-up for any human flinching
		{
			motor[LDrive] = 0;
			motor[RDrive] = 0;
		}
		else
		{
			left = pow(vexRT[Ch3],3)/pow(127,2) + pow(vexRT[Ch4],3)/pow(127,2);
			right = pow(vexRT[Ch3],3)/pow(127,2) - pow(vexRT[Ch4],3)/pow(127,2);	//Slope calculation
			if(left > 127)
			{
				left=127;
			}
			else if(left < -127)
			{
				left = -127;
			}
			if(right > 127)
			{
				right = 127;
			}
			else if(right < -127)
			{
				right = -127;
			}
			motor[LDrive] = left;
			motor[RDrive] = right;
		}
	}
}

/*===================================================================================*/

task ClawTask(){
	int openC = -90;
	int closeC = 127;

	motor[TriClaw] = openC;

	while (true)
	{
		if(vexRT[Btn8D] == true)
		{
			motor[TriClaw] = openC;
		}
		else if(vexRT[Btn8L] == true)
		{
			motor[TriClaw] = closeC;
		}
	}
}

/*===================================================================================*/

task ArmCtrl(){
	float move;

	while(true)
	{
		if(abs(vexRT[Ch2]) < 10)
		{
			motor[Arm] = 0;
		}
		else
		{
			move = pow(vexRT[Ch2],3)/pow(127,2);	//To create a smoother movement for the arm
			if(move > 127)
			{
				move = 127;
			}
			else if(move < -127)
			{
				move = -127;
			}

		motor[Arm] = move;	//Set the movement

		}
	}
}

/*===================================================================================*/

task AutoModeA(){	//Autonomous
	motor[LDrive] = 127;
	motor[RDrive] = 127;
	wait1Msec(2400);
	motor[LDrive] = 0;
	motor[RDrive] = 0;
	wait1Msec(100);
	motor[LDrive] = -127;
	motor[RDrive] = -127;
	wait1Msec(400);
	motor[LDrive] = 0;
	motor[RDrive] = 0;
	startTask (drive);
}

/*===================================================================================*/

task AutoModeB(){	//Autonomous
	motor[LDrive] = 127;
	motor[RDrive] = 127;
	wait1Msec(3300);
	motor[LDrive] = 0;
	motor[RDrive] = 0;
	wait1Msec(100);
	motor[LDrive] = -127;
	motor[RDrive] = -127;
	wait1Msec(500);
	motor[LDrive] = 0;
	motor[RDrive] = 0;
	startTask (drive);
}

/*===================================================================================*/

task Dancing(){ //Dance party
	motor[Arm] = 127;
	motor[LDrive] = 127;
	motor[RDrive] = -127;
	wait1Msec(500);
	motor[Arm] = 0;
	wait1Msec(100);
	motor[Arm] = -127;
	wait1Msec(300);
	motor[Arm] = 0;
	motor[LDrive] = 0;
	motor[RDrive] = 0;
	wait1Msec(100);
	motor[LDrive] = -127;
	motor[RDrive] = 127;
	wait1Msec(1000);
	motor[LDrive] = 0;
	motor[RDrive] = 0;
	wait1Msec(100);
	motor[LDrive] = 127;
	wait1Msec(500);
	motor[LDrive] = 0;
	wait1Msec(100);
	motor[RDrive] = 127;
	wait1Msec(500);
	motor[RDrive] = 0;
	wait1Msec(100);
	motor[LDrive] = 127;
	wait1Msec(500);
	motor[LDrive] = 0;
	wait1Msec(100);
	motor[LDrive] = -127;
	wait1Msec(500);
	motor[LDrive] = 0;
	wait1Msec(100);
	motor[RDrive] = -127;
	wait1Msec(500);
	motor[RDrive] = 0;
	wait1Msec(100);
	motor[LDrive] = -127;
	wait1Msec(500);
	motor[LDrive] = 0;
	motor[Arm] = 127;
	wait1Msec(300);
	motor[Arm] = 0;
	wait1Msec(100);
	motor[Arm] = -127;
	motor[LDrive] = -127;
	motor[RDrive] = 127;
	wait1Msec(500);
	motor[Arm] = 0;
	wait1Msec(200);
	motor[LDrive] = 0;
	motor[RDrive] = 0;
	wait1Msec(100);
	motor[LDrive] = 127;
	motor[RDrive] = 127;
	wait1Msec(100);
	motor[Arm] = 127;
	wait1Msec(600);
	motor[Arm] = 0;
	motor[LDrive] = 0;
	motor[RDrive] = 0;
	wait1Msec(100);
	motor[LDrive] = -127;
	motor[RDrive] = -127;
	wait1Msec(200);
	motor[LDrive] = 127;
	motor[RDrive] = 127;
	wait1Msec(200);
	motor[LDrive] = 0;
	motor[RDrive] = 0;
	startTask (drive);
}

/*===================================================================================*/

task main(){
	startTask(drive);
	startTask(ClawTask);
	startTask(ArmCtrl);

	bool autoA = false;
	bool autoB = false;
	bool dance = false;

	while(true){
		wait1Msec(10);
		if(vexRT[Btn7U] == true && autoA == false)
		{
			autoA = true;
			stopTask(drive);	//To keep the drive task from interfeering with the robot
			startTask(AutoModeA);
		}
		else if(autoA == true && (abs(vexRT[Ch2]) > 10 || abs(vexRT[Ch3]) > 10 || abs(vexRT[Ch4]) > 10 || vexRT[Btn8U] == true || vexRT[Btn8D] == true))
		{
			autoB = false;
			stopTask(AutoModeA);
			startTask(drive);
		}
				if(vexRT[Btn7D] == true && autoB == false)
		{
			autoB = true;
			stopTask(drive);	//To keep the drive task from interfeering with the robot
			startTask(AutoModeB);
		}
		else if(autoB == true && (abs(vexRT[Ch2]) > 10 || abs(vexRT[Ch3]) > 10 || abs(vexRT[Ch4]) > 10 || vexRT[Btn8U] == true || vexRT[Btn8D] == true))
		{
			autoB = false;
			stopTask(AutoModeB);
			startTask(drive);
		}

		//DANCE
				if(vexRT[Btn7R] == true && vexRT[Btn7L] == true && vexRT[Btn5U] == true && vexRT[Btn6U] == true && dance == false)
		{
			dance = true;
			stopTask(drive);	//To keep the drive task from interfeering with the dance party
			startTask(Dancing);
		}
		else if(dance == true && (abs(vexRT[Ch2]) > 10 || abs(vexRT[Ch3]) > 10 || abs(vexRT[Ch4]) > 10 || vexRT[Btn8U] == true || vexRT[Btn8D] == true))
		{
			dance = false;
			stopTask(Dancing);
			startTask(drive);
		}
	}
}	// End of Code
